Timer unit: 1e-06 s

Total time: 64.3114 s
File: estare/src/align.py
Function: detrans at line 20

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    20                                           @profile
    21                                           def detrans(x_array, y_array, x_range, y_range, del_x, del_y):
    22                                           
    23                                               '''
    24                                           Corrects the effect of translation by removing the extent by which each point 
    25                                           had been shifted, i.e. del_x, and del_y.
    26                                           '''
    27      4001       1826.0      0.5      0.0      for i in range(x_range):
    28  24004000    9298682.0      0.4     14.5          for j in range(y_range):
    29  24000000   27422698.0      1.1     42.6              x_array[i, j] = i-del_x
    30  24000000   27588197.0      1.1     42.9              y_array[i, j] = j-del_y
    31                                           
    32         1          1.0      1.0      0.0      return x_array, y_array

Total time: 1683.58 s
File: estare/src/align.py
Function: align at line 34

Line #      Hits         Time  Per Hit   % Time  Line Contents
==============================================================
    34                                           @profile
    35                                           def align(image_1, image_2, pivot_1, pivot_2):
    36                                             
    37         1     491888.0 491888.0      0.0      img_1, x_range_1, y_range_1 = examine(image_1)  
    38         1     471755.0 471755.0      0.0      img_2, x_range_2, y_range_2 = examine(image_2)
    39                                           
    40                                               # TODO: How to raise error here?
    41                                               # if (x_range_1 != x_range_2) or (y_range_1 != y_range_2):
    42                                               #     #TODO: raise error and exit
    43                                               #     pass   # JUST FOR NOW!
    44                                               
    45                                               # two reference points for alignment
    46         1      23679.0  23679.0      0.0      coord_1 = np.load(pivot_1)
    47         1          3.0      3.0      0.0      a_1 = coord_1[0]
    48         1          1.0      1.0      0.0      b_1 = coord_1[1]
    49                                               
    50                                               # two target points that should match the reference points after alignment
    51         1        779.0    779.0      0.0      coord_2 = np.load(pivot_2)  
    52         1          2.0      2.0      0.0      a_2 = coord_2[0]
    53         1          1.0      1.0      0.0      b_2 = coord_2[1]
    54                                           
    55                                               # Use the two points to back calculate the angle of rotation
    56         1          4.0      4.0      0.0      slope_bef = ( b_1[1] - a_1[1] )/( b_1[0] - a_1[0] )
    57                                               
    58         1          2.0      2.0      0.0      slope_aft = ( b_2[1] - a_2[1] )/( b_2[0] - a_2[0] )
    59                                           
    60         2         19.0      9.5      0.0      theta = ( ((np.arctan(slope_aft))*180/np.pi) -
    61         1          5.0      5.0      0.0                ( (np.arctan(slope_bef))*180/np.pi ) )
    62                                           
    63         1         57.0     57.0      0.0      a2_derot = rotate(a_2, -theta, discrete=False)   # set discrete=False to get an exact value
    64                                           
    65                                               # compare the derotated one from its origin to calculate the relative translation magnitude 
    66         1          2.0      2.0      0.0      dxp = a2_derot[0] - a_1[0]
    67         1          1.0      1.0      0.0      dyp = a2_derot[1] - a_1[1]
    68                                           
    69                                               # Using the formulae, compute the absolute translation magnitude
    70         1          2.0      2.0      0.0      theta_rad = -theta * np.pi / 180   # radians
    71                                           
    72         2          5.0      2.5      0.0      del_y = ( dyp - dxp*np.tan(theta_rad) ) / \
    73         1          6.0      6.0      0.0              (np.sin(theta_rad)*np.tan(theta_rad) + np.cos(theta_rad))
    74                                           
    75         1          5.0      5.0      0.0      del_x = (dxp + del_y*np.sin(theta_rad)) / np.cos(theta_rad)
    76                                               
    77                                               # Allocate x- and y-array for holding the new coordinates after offseting
    78         1         14.0     14.0      0.0      x_array = np.zeros((x_range_1, y_range_1, 1), dtype=int)
    79         1          5.0      5.0      0.0      y_array = np.zeros((x_range_1, y_range_1, 1), dtype=int)
    80                                           
    81                                           
    82                                               # For the two following time-consuming loops, we need unit tests to ensure the correctness after each optimization:
    83                                               # Now we can detranslate all points
    84         1          3.0      3.0      0.0      t_1 = time.time()
    85                                           
    86         1   86288226.0 86288226.0      5.1      x_array, y_array = detrans(x_array, y_array, x_range_1, y_range_1, del_x, del_y)
    87                                                       
    88         1          3.0      3.0      0.0      t_2 = time.time()
    89                                               # and now we can derotate them 
    90      4001       4228.0      1.1      0.0      for i in range(x_range_1):
    91  24004000   23567524.0      1.0      1.4          for j in range(y_range_1):
    92  24000000   41537153.0      1.7      2.5              uncorrected_coor = [x_array[i, j], y_array[i, j]]
    93  24000000 1064508160.0     44.4     63.2              corrected_coor = rotate(uncorrected_coor, -theta, discrete=True)
    94                                                       
    95  24000000   51360299.0      2.1      3.1              x_array[i, j] = corrected_coor[0]
    96  24000000   37858085.0      1.6      2.2              y_array[i, j] = corrected_coor[1]
    97                                           
    98                                                       # stack
    99  24000000  167251223.0      7.0      9.9              if x_array[i, j] > 0 and x_array[i, j] < x_range_1 and y_array[i, j] > 0 and y_array[i, j] < y_range_1:
   100  23871455  207809408.0      8.7     12.3                  img_1[x_array[i, j], y_array[i, j]] += img_2[i, j]   # Broadcasting to all three channels is implicit
   101                                                       
   102         1          3.0      3.0      0.0      t_3 = time.time()
   103                                           
   104         1         34.0     34.0      0.0      print('De-translation took %s sec.'%(t_2-t_1))
   105         1          9.0      9.0      0.0      print('Stacking took %s sec.'%(t_3-t_2))
   106         1          5.0      5.0      0.0      print('Done')
   107         1    2407309.0 2407309.0      0.1      io.imsave('/home/minter/workdir/Central_backup/Pictures/Test_images_for_estare_Ramberget_Dec_2020/estare_stacked.JPG', img_1)

